/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2024.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`post_metadata_templates_schema_classifications`]
#[derive(Clone, Debug)]
pub struct PostMetadataTemplatesSchemaClassificationsParams {
    pub post_metadata_templates_schema_classifications_request: Option<models::PostMetadataTemplatesSchemaClassificationsRequest>
}

/// struct for passing parameters to the method [`put_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema_add`]
#[derive(Clone, Debug)]
pub struct PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaAddParams {
    pub put_metadata_templates_enterprise_security_classification_6_vm_vochw_uwo_schema_add_request_inner: Option<Vec<models::PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaAddRequestInner>>
}

/// struct for passing parameters to the method [`put_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema_update`]
#[derive(Clone, Debug)]
pub struct PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaUpdateParams {
    pub put_metadata_templates_enterprise_security_classification_6_vm_vochw_uwo_schema_update_request_inner: Option<Vec<models::PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaUpdateRequestInner>>
}


/// struct for typed errors of method [`get_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaError {
    Status400(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_metadata_templates_schema_classifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMetadataTemplatesSchemaClassificationsError {
    Status400(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaAddError {
    Status400(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaUpdateError {
    Status400(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}


/// Retrieves the classification metadata template and lists all the classifications available to this enterprise.  This API can also be called by including the enterprise ID in the URL explicitly, for example `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
pub async fn get_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema(configuration: &configuration::Configuration) -> Result<models::ClassificationTemplate, Error<GetMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaError>> {

    let uri_str = format!("{}/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClassificationTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClassificationTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// When an enterprise does not yet have any classifications, this API call initializes the classification template with an initial set of classifications.  If an enterprise already has a classification, the template will already exist and instead an API call should be made to add additional classifications.
pub async fn post_metadata_templates_schema_classifications(configuration: &configuration::Configuration, params: PostMetadataTemplatesSchemaClassificationsParams) -> Result<models::ClassificationTemplate, Error<PostMetadataTemplatesSchemaClassificationsError>> {

    let uri_str = format!("{}/metadata_templates/schema#classifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.post_metadata_templates_schema_classifications_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClassificationTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClassificationTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostMetadataTemplatesSchemaClassificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds one or more new classifications to the list of classifications available to the enterprise.  This API can also be called by including the enterprise ID in the URL explicitly, for example `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
pub async fn put_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema_add(configuration: &configuration::Configuration, params: PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaAddParams) -> Result<models::ClassificationTemplate, Error<PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaAddError>> {

    let uri_str = format!("{}/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#add", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.put_metadata_templates_enterprise_security_classification_6_vm_vochw_uwo_schema_add_request_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClassificationTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClassificationTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the labels and descriptions of one or more classifications available to the enterprise.  This API can also be called by including the enterprise ID in the URL explicitly, for example `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
pub async fn put_metadata_templates_enterprise_security_classification6_vm_vochw_uwo_schema_update(configuration: &configuration::Configuration, params: PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaUpdateParams) -> Result<models::ClassificationTemplate, Error<PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaUpdateError>> {

    let uri_str = format!("{}/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.put_metadata_templates_enterprise_security_classification_6_vm_vochw_uwo_schema_update_request_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClassificationTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClassificationTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutMetadataTemplatesEnterpriseSecurityClassification6VmVochwUwoSchemaUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

