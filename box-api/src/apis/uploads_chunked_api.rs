/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2024.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};

/// struct for passing parameters to the method [`delete_files_upload_sessions_id`]
#[derive(Clone, Debug)]
pub struct DeleteFilesUploadSessionsIdParams {
    /// The ID of the upload session.
    pub upload_session_id: String
}

/// struct for passing parameters to the method [`get_files_upload_sessions_id`]
#[derive(Clone, Debug)]
pub struct GetFilesUploadSessionsIdParams {
    /// The ID of the upload session.
    pub upload_session_id: String
}

/// struct for passing parameters to the method [`get_files_upload_sessions_id_parts`]
#[derive(Clone, Debug)]
pub struct GetFilesUploadSessionsIdPartsParams {
    /// The ID of the upload session.
    pub upload_session_id: String,
    /// The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response.
    pub offset: Option<i64>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`post_files_id_upload_sessions`]
#[derive(Clone, Debug)]
pub struct PostFilesIdUploadSessionsParams {
    /// The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL `https://_*.app.box.com/files/123` the `file_id` is `123`.
    pub file_id: String,
    pub post_files_id_upload_sessions_request: Option<models::PostFilesIdUploadSessionsRequest>
}

/// struct for passing parameters to the method [`post_files_upload_sessions`]
#[derive(Clone, Debug)]
pub struct PostFilesUploadSessionsParams {
    pub post_files_upload_sessions_request: Option<models::PostFilesUploadSessionsRequest>
}

/// struct for passing parameters to the method [`post_files_upload_sessions_id_commit`]
#[derive(Clone, Debug)]
pub struct PostFilesUploadSessionsIdCommitParams {
    /// The ID of the upload session.
    pub upload_session_id: String,
    /// The [RFC3230][1] message digest of the whole file.  Only SHA1 is supported. The SHA1 digest must be Base64 encoded. The format of this header is as `sha=BASE64_ENCODED_DIGEST`.  [1]: https://tools.ietf.org/html/rfc3230
    pub digest: String,
    /// Ensures this item hasn't recently changed before making changes.  Pass in the item's last observed `etag` value into this header and the endpoint will fail with a `412 Precondition Failed` if it has changed since.
    pub if_match: Option<String>,
    /// Ensures an item is only returned if it has changed.  Pass in the item's last observed `etag` value into this header and the endpoint will fail with a `304 Not Modified` if the item has not changed since.
    pub if_none_match: Option<String>,
    pub post_files_upload_sessions_id_commit_request: Option<models::PostFilesUploadSessionsIdCommitRequest>
}

/// struct for passing parameters to the method [`put_files_upload_sessions_id`]
#[derive(Clone, Debug)]
pub struct PutFilesUploadSessionsIdParams {
    /// The ID of the upload session.
    pub upload_session_id: String,
    /// The [RFC3230][1] message digest of the chunk uploaded.  Only SHA1 is supported. The SHA1 digest must be base64 encoded. The format of this header is as `sha=BASE64_ENCODED_DIGEST`.  To get the value for the `SHA` digest, use the openSSL command to encode the file part: `openssl sha1 -binary <FILE_PART_NAME> | base64`.  [1]: https://tools.ietf.org/html/rfc3230
    pub digest: String,
    /// The byte range of the chunk.  Must not overlap with the range of a part already uploaded this session. Each partâ€™s size must be exactly equal in size to the part size specified in the upload session that you created. One exception is the last part of the file, as this can be smaller.  When providing the value for `content-range`, remember that:  * The lower bound of each part's byte range   must be a multiple of the part size. * The higher bound must be a multiple of the part size - 1.
    pub content_range: String,
    pub body: Option<std::path::PathBuf>
}


/// struct for typed errors of method [`delete_files_upload_sessions_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFilesUploadSessionsIdError {
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_files_upload_sessions_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesUploadSessionsIdError {
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_files_upload_sessions_id_parts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesUploadSessionsIdPartsError {
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_id_upload_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesIdUploadSessionsError {
    Status409(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_upload_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesUploadSessionsError {
    Status400(models::ClientError),
    Status403(models::ClientError),
    Status404(models::ClientError),
    Status409(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_files_upload_sessions_id_commit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostFilesUploadSessionsIdCommitError {
    Status409(models::ClientError),
    Status412(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_files_upload_sessions_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutFilesUploadSessionsIdError {
    Status409(models::ClientError),
    Status412(models::ClientError),
    Status416(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}


/// Abort an upload session and discard all data uploaded.  This cannot be reversed.  The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
pub async fn delete_files_upload_sessions_id(configuration: &configuration::Configuration, params: DeleteFilesUploadSessionsIdParams) -> Result<(), Error<DeleteFilesUploadSessionsIdError>> {

    let uri_str = format!("{}/files/upload_sessions/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(params.upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFilesUploadSessionsIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return information about an upload session.  The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) endpoint.
pub async fn get_files_upload_sessions_id(configuration: &configuration::Configuration, params: GetFilesUploadSessionsIdParams) -> Result<models::UploadSession, Error<GetFilesUploadSessionsIdError>> {

    let uri_str = format!("{}/files/upload_sessions/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(params.upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadSession`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadSession`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFilesUploadSessionsIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return a list of the chunks uploaded to the upload session so far.  The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
pub async fn get_files_upload_sessions_id_parts(configuration: &configuration::Configuration, params: GetFilesUploadSessionsIdPartsParams) -> Result<models::UploadParts, Error<GetFilesUploadSessionsIdPartsError>> {

    let uri_str = format!("{}/files/upload_sessions/{upload_session_id}/parts", configuration.base_path, upload_session_id=crate::apis::urlencode(params.upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadParts`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadParts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFilesUploadSessionsIdPartsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an upload session for an existing file.
pub async fn post_files_id_upload_sessions(configuration: &configuration::Configuration, params: PostFilesIdUploadSessionsParams) -> Result<models::UploadSession, Error<PostFilesIdUploadSessionsError>> {

    let uri_str = format!("{}/files/{file_id}/upload_sessions", configuration.base_path, file_id=crate::apis::urlencode(params.file_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.post_files_id_upload_sessions_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadSession`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadSession`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostFilesIdUploadSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an upload session for a new file.
pub async fn post_files_upload_sessions(configuration: &configuration::Configuration, params: PostFilesUploadSessionsParams) -> Result<models::UploadSession, Error<PostFilesUploadSessionsError>> {

    let uri_str = format!("{}/files/upload_sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.post_files_upload_sessions_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadSession`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadSession`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostFilesUploadSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close an upload session and create a file from the uploaded chunks.  The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
pub async fn post_files_upload_sessions_id_commit(configuration: &configuration::Configuration, params: PostFilesUploadSessionsIdCommitParams) -> Result<models::Files, Error<PostFilesUploadSessionsIdCommitError>> {

    let uri_str = format!("{}/files/upload_sessions/{upload_session_id}/commit", configuration.base_path, upload_session_id=crate::apis::urlencode(params.upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("digest", params.digest.to_string());
    if let Some(param_value) = params.if_match {
        req_builder = req_builder.header("if-match", param_value.to_string());
    }
    if let Some(param_value) = params.if_none_match {
        req_builder = req_builder.header("if-none-match", param_value.to_string());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.post_files_upload_sessions_id_commit_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Files`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Files`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostFilesUploadSessionsIdCommitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Uploads a chunk of a file for an upload session.  The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
pub async fn put_files_upload_sessions_id(configuration: &configuration::Configuration, params: PutFilesUploadSessionsIdParams) -> Result<models::UploadedPart, Error<PutFilesUploadSessionsIdError>> {

    let uri_str = format!("{}/files/upload_sessions/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(params.upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("digest", params.digest.to_string());
    req_builder = req_builder.header("content-range", params.content_range.to_string());
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(param_value) = params.body {
        let file = TokioFile::open(param_value).await?;
        let stream = FramedRead::new(file, BytesCodec::new());
        req_builder = req_builder.body(reqwest::Body::wrap_stream(stream));
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadedPart`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadedPart`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutFilesUploadSessionsIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

