/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2024.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`delete_metadata_templates_id_id_schema`]
#[derive(Clone, Debug)]
pub struct DeleteMetadataTemplatesIdIdSchemaParams {
    /// The scope of the metadata template.
    pub scope: String,
    /// The name of the metadata template.
    pub template_key: String
}

/// struct for passing parameters to the method [`get_metadata_templates`]
#[derive(Clone, Debug)]
pub struct GetMetadataTemplatesParams {
    /// The ID of an instance of the metadata template to find.
    pub metadata_instance_id: String,
    /// Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    pub marker: Option<String>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`get_metadata_templates_enterprise`]
#[derive(Clone, Debug)]
pub struct GetMetadataTemplatesEnterpriseParams {
    /// Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    pub marker: Option<String>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`get_metadata_templates_global`]
#[derive(Clone, Debug)]
pub struct GetMetadataTemplatesGlobalParams {
    /// Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    pub marker: Option<String>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`get_metadata_templates_id`]
#[derive(Clone, Debug)]
pub struct GetMetadataTemplatesIdParams {
    /// The ID of the template.
    pub template_id: String
}

/// struct for passing parameters to the method [`get_metadata_templates_id_id_schema`]
#[derive(Clone, Debug)]
pub struct GetMetadataTemplatesIdIdSchemaParams {
    /// The scope of the metadata template.
    pub scope: String,
    /// The name of the metadata template.
    pub template_key: String
}

/// struct for passing parameters to the method [`post_metadata_templates_schema`]
#[derive(Clone, Debug)]
pub struct PostMetadataTemplatesSchemaParams {
    pub post_metadata_templates_schema_request: Option<models::PostMetadataTemplatesSchemaRequest>
}

/// struct for passing parameters to the method [`put_metadata_templates_id_id_schema`]
#[derive(Clone, Debug)]
pub struct PutMetadataTemplatesIdIdSchemaParams {
    /// The scope of the metadata template.
    pub scope: String,
    /// The name of the metadata template.
    pub template_key: String,
    pub a_metadata_template_update_operation: Option<Vec<models::AMetadataTemplateUpdateOperation>>
}


/// struct for typed errors of method [`delete_metadata_templates_id_id_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMetadataTemplatesIdIdSchemaError {
    Status400(models::ClientError),
    Status403(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesError {
    Status400(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_enterprise`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesEnterpriseError {
    Status400(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_global`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesGlobalError {
    Status400(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesIdError {
    Status400(models::MetadataTemplate),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_metadata_templates_id_id_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMetadataTemplatesIdIdSchemaError {
    Status400(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_metadata_templates_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMetadataTemplatesSchemaError {
    Status400(models::ClientError),
    Status403(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_metadata_templates_id_id_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutMetadataTemplatesIdIdSchemaError {
    Status400(models::ClientError),
    Status403(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}


/// Delete a metadata template and its instances. This deletion is permanent and can not be reversed.
pub async fn delete_metadata_templates_id_id_schema(configuration: &configuration::Configuration, params: DeleteMetadataTemplatesIdIdSchemaParams) -> Result<(), Error<DeleteMetadataTemplatesIdIdSchemaError>> {

    let uri_str = format!("{}/metadata_templates/{scope}/{template_key}/schema", configuration.base_path, scope=crate::apis::urlencode(params.scope), template_key=crate::apis::urlencode(params.template_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMetadataTemplatesIdIdSchemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Finds a metadata template by searching for the ID of an instance of the template.
pub async fn get_metadata_templates(configuration: &configuration::Configuration, params: GetMetadataTemplatesParams) -> Result<models::MetadataTemplates, Error<GetMetadataTemplatesError>> {

    let uri_str = format!("{}/metadata_templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("metadata_instance_id", &params.metadata_instance_id.to_string())]);
    if let Some(ref param_value) = params.marker {
        req_builder = req_builder.query(&[("marker", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplates`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplates`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMetadataTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Used to retrieve all metadata templates created to be used specifically within the user's enterprise.
pub async fn get_metadata_templates_enterprise(configuration: &configuration::Configuration, params: GetMetadataTemplatesEnterpriseParams) -> Result<models::MetadataTemplates, Error<GetMetadataTemplatesEnterpriseError>> {

    let uri_str = format!("{}/metadata_templates/enterprise", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.marker {
        req_builder = req_builder.query(&[("marker", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplates`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplates`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMetadataTemplatesEnterpriseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Used to retrieve all generic, global metadata templates available to all enterprises using Box.
pub async fn get_metadata_templates_global(configuration: &configuration::Configuration, params: GetMetadataTemplatesGlobalParams) -> Result<models::MetadataTemplates, Error<GetMetadataTemplatesGlobalError>> {

    let uri_str = format!("{}/metadata_templates/global", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.marker {
        req_builder = req_builder.query(&[("marker", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplates`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplates`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMetadataTemplatesGlobalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a metadata template by its ID.
pub async fn get_metadata_templates_id(configuration: &configuration::Configuration, params: GetMetadataTemplatesIdParams) -> Result<models::MetadataTemplate, Error<GetMetadataTemplatesIdError>> {

    let uri_str = format!("{}/metadata_templates/{template_id}", configuration.base_path, template_id=crate::apis::urlencode(params.template_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMetadataTemplatesIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a metadata template by its `scope` and `templateKey` values.  To find the `scope` and `templateKey` for a template, list all templates for an enterprise or globally, or list all templates applied to a file or folder.
pub async fn get_metadata_templates_id_id_schema(configuration: &configuration::Configuration, params: GetMetadataTemplatesIdIdSchemaParams) -> Result<models::MetadataTemplate, Error<GetMetadataTemplatesIdIdSchemaError>> {

    let uri_str = format!("{}/metadata_templates/{scope}/{template_key}/schema", configuration.base_path, scope=crate::apis::urlencode(params.scope), template_key=crate::apis::urlencode(params.template_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMetadataTemplatesIdIdSchemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new metadata template that can be applied to files and folders.
pub async fn post_metadata_templates_schema(configuration: &configuration::Configuration, params: PostMetadataTemplatesSchemaParams) -> Result<models::MetadataTemplate, Error<PostMetadataTemplatesSchemaError>> {

    let uri_str = format!("{}/metadata_templates/schema", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.post_metadata_templates_schema_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostMetadataTemplatesSchemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a metadata template.  The metadata template can only be updated if the template already exists.  The update is applied atomically. If any errors occur during the application of the operations, the metadata template will not be changed.
pub async fn put_metadata_templates_id_id_schema(configuration: &configuration::Configuration, params: PutMetadataTemplatesIdIdSchemaParams) -> Result<models::MetadataTemplate, Error<PutMetadataTemplatesIdIdSchemaError>> {

    let uri_str = format!("{}/metadata_templates/{scope}/{template_key}/schema", configuration.base_path, scope=crate::apis::urlencode(params.scope), template_key=crate::apis::urlencode(params.template_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.a_metadata_template_update_operation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetadataTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetadataTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutMetadataTemplatesIdIdSchemaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

