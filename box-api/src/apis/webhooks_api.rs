/*
 * Box Platform API
 *
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2024.0
 * Contact: devrel@box.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`delete_webhooks_id`]
#[derive(Clone, Debug)]
pub struct DeleteWebhooksIdParams {
    /// The ID of the webhook.
    pub webhook_id: String
}

/// struct for passing parameters to the method [`get_webhooks`]
#[derive(Clone, Debug)]
pub struct GetWebhooksParams {
    /// Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    pub marker: Option<String>,
    /// The maximum number of items to return per page.
    pub limit: Option<i64>
}

/// struct for passing parameters to the method [`get_webhooks_id`]
#[derive(Clone, Debug)]
pub struct GetWebhooksIdParams {
    /// The ID of the webhook.
    pub webhook_id: String
}

/// struct for passing parameters to the method [`post_webhooks`]
#[derive(Clone, Debug)]
pub struct PostWebhooksParams {
    pub post_webhooks_request: Option<models::PostWebhooksRequest>
}

/// struct for passing parameters to the method [`put_webhooks_id`]
#[derive(Clone, Debug)]
pub struct PutWebhooksIdParams {
    /// The ID of the webhook.
    pub webhook_id: String,
    pub put_webhooks_id_request: Option<models::PutWebhooksIdRequest>
}


/// struct for typed errors of method [`delete_webhooks_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhooksIdError {
    Status403(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhooks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhooksError {
    Status403(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhooks_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhooksIdError {
    Status403(models::ClientError),
    Status404(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_webhooks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWebhooksError {
    Status400(models::ClientError),
    Status403(models::ClientError),
    Status404(models::ClientError),
    Status409(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_webhooks_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutWebhooksIdError {
    Status400(models::ClientError),
    Status403(models::ClientError),
    Status404(models::ClientError),
    Status409(models::ClientError),
    DefaultResponse(models::ClientError),
    UnknownValue(serde_json::Value),
}


/// Deletes a webhook.
pub async fn delete_webhooks_id(configuration: &configuration::Configuration, params: DeleteWebhooksIdParams) -> Result<(), Error<DeleteWebhooksIdError>> {

    let uri_str = format!("{}/webhooks/{webhook_id}", configuration.base_path, webhook_id=crate::apis::urlencode(params.webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWebhooksIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns all defined webhooks for the requesting application.  This API only returns webhooks that are applied to files or folders that are owned by the authenticated user. This means that an admin can not see webhooks created by a service account unless the admin has access to those folders, and vice versa.
pub async fn get_webhooks(configuration: &configuration::Configuration, params: GetWebhooksParams) -> Result<models::Webhooks, Error<GetWebhooksError>> {

    let uri_str = format!("{}/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.marker {
        req_builder = req_builder.query(&[("marker", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Webhooks`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Webhooks`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific webhook.
pub async fn get_webhooks_id(configuration: &configuration::Configuration, params: GetWebhooksIdParams) -> Result<models::Webhook, Error<GetWebhooksIdError>> {

    let uri_str = format!("{}/webhooks/{webhook_id}", configuration.base_path, webhook_id=crate::apis::urlencode(params.webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Webhook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Webhook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhooksIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a webhook.
pub async fn post_webhooks(configuration: &configuration::Configuration, params: PostWebhooksParams) -> Result<models::Webhook, Error<PostWebhooksError>> {

    let uri_str = format!("{}/webhooks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.post_webhooks_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Webhook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Webhook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWebhooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates a webhook.
pub async fn put_webhooks_id(configuration: &configuration::Configuration, params: PutWebhooksIdParams) -> Result<models::Webhook, Error<PutWebhooksIdError>> {

    let uri_str = format!("{}/webhooks/{webhook_id}", configuration.base_path, webhook_id=crate::apis::urlencode(params.webhook_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.put_webhooks_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Webhook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Webhook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutWebhooksIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

